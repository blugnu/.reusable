name: 'job: module qa'
on:
  workflow_call:
    inputs:
      testReportVersion:
        description: 'The version of test-report to use'
        type: string
        required: false
        default: 'latest'
    outputs:
      moduleName:
        value: ${{ jobs.module-info.outputs.moduleName }}
      goVersion:
        value: ${{ jobs.module-info.outputs.goVersion }}
      isPublic:
        value: ${{ jobs.module-info.outputs.isPublic }}
      usesGoReleaser:
        value: ${{ jobs.module-info.outputs.usesGoReleaser }}
      semver:
        value: ${{ jobs.semver.outputs.semver }}
      isTagged:
        value: ${{ jobs.semver.outputs.isTagged }}
  
jobs:
  semver:
    uses: ./.github/workflows/job.git-semver.yml

  module-info:
    uses: ./.github/workflows/job.module-info.yml

  tests:
    if: ${{ (github.ref != 'refs/heads/master' ) || (needs.module-info.outputs.isPublic == 'true' ) }}
    needs:
      - module-info
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4

      # install go
      - name: 'setup: go ${{ needs.module-info.outputs.goVersion }}'
        uses: actions/setup-go@v5
        with:
          go-version: ${{ needs.module-info.outputs.goVersion }}
          cache: false   # avoid "file exists" errors from tar: https://github.com/actions/setup-go/issues/403

      # ensure that go.mod is tidy
      - name: 'go.mod: tidy'
        id: tidy
        run: |
          # a script to determine whether 'go mod tidy' is required

          before=$(cat go.mod go.sum | shasum -a 256)
          echo "::group::go mod tidy output"
            go mod tidy
          echo "::endgroup::"
          after=$(cat go.mod go.sum | shasum -a 256)
          
          if [[ "$before" != "$after" ]]; then
            echo "::error::'go mod tidy' is required; updated go.mod/go.sum must be committed"
            exit -1
          fi

      # lint checks
      - name: 'go: lint'
        if: ${{ github.ref != 'refs/heads/master' }}
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest

      # if we get this far then we have a module which has passed basic hygiene
      # checks and is ready to run any tests
  
      # install test-report
      - name: 'setup: test-report'
        run: |
          # a script to download and run blugnu/test-report

          ver="${{ inputs.testReportVersion }}"
          [[ "$ver" =~ "^v.*" ]] && ver="${ver:1}"
          if [[ "$ver" == "latest" ]]; then
            ver=$(curl -s https://api.github.com/repos/blugnu/test-report/releases/latest | jq -r '.tag_name' | cut -c 2-)
            echo "downloading (latest): v$ver"
          else
            echo "downloading: v$ver"
          fi

          # download test-report from blugnu/test-report/releases
          curl -LO https://github.com/blugnu/test-report/releases/download/v${ver}/test-report_${ver}_linux_amd64.tar.gz
          tar -xvzf test-report_${ver}_linux_amd64.tar.gz test-report
          rm test-report_${ver}_linux_amd64.tar.gz
          
          if [[ ! -f "test-report" ]]; then
            echo "::warning::test-report could not be installed"
            echo -e "## :warning: &nbsp; Module QA\n" >> $GITHUB_STEP_SUMMARY
            echo -e ":information_source: &nbsp; `test-report` could not be installed\n" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          echo "::group::test-report version"
            ./test-report version
          echo "::endgroup::"
    
      # run tests
      - name: 'go: test'
        run: |
          go mod download

          if [[ -f test-report ]]; then
            result=$((go test ./... -coverprofile=coverprofile -json | ./test-report) && echo "PASS" || echo "FAIL")
            
            # add test report to the job summary
            report=$(cat test-report.md)
            echo -e "$report\n" >> $GITHUB_STEP_SUMMARY

            if [[ "$result" == "FAIL" ]]; then
              echo "::error::tests failed"
              exit 1
            fi
          else
            go test -v -coverprofile=coverprofile ./...
          fi

      - name: 'artifact: upload [coverprofile]'
        uses: actions/upload-artifact@v4
        with:
          name: coverprofile
          path: coverprofile

  coveralls:
    if: ${{ (github.ref == 'refs/heads/master') && (needs.module-info.outputs.isPublic == 'true') && (needs.semver.outputs.isTagged == 'false') }}
    needs:
      - semver
      - module-info
      - tests # for sequencing; coveralls requires the coverprofile artefact uploaded by tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 'artifact: download [coverprofile]'
        uses: actions/download-artifact@v4
        with:
          name: coverprofile

      - name: 'coveralls: send coverage'
        uses: shogo82148/actions-goveralls@v1
        with:
          path-to-profile: coverprofile

  sonarcloud:
    if: ${{ needs.module-info.outputs.isPublic == 'true' && (needs.semver.outputs.isTagged == 'false') }}
    needs:
      - semver
      - module-info
      - tests # for job sequencing; we only want to run sonarcloud if tests have passed
    uses: ./.github/workflows/job.sonarcloud.yml
    with:
      moduleName: ${{ needs.module-info.outputs.moduleName }}
      moduleVersion: ${{ needs.semver.outputs.semver }}
    secrets: inherit
